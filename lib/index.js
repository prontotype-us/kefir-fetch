// Generated by CoffeeScript 1.10.0
var Kefir, deepExtend, fetch$, makeQueryString, timeoutPromise;

if (typeof fetch === "undefined" || fetch === null) {
  require('whatwg-fetch');
}

deepExtend = require('deep-extend');

Kefir = require('kefir');

makeQueryString = function(query) {
  var k, s, v;
  s = "?";
  for (k in query) {
    v = query[k];
    if (v != null) {
      s += k + "=" + v + "&";
    }
  }
  return s;
};

timeoutPromise = function(context, p, ms) {
  return new Promise(function(resolve, reject) {
    var clear_rej, clear_res, timeout_timeout;
    timeout_timeout = setTimeout(function() {
      var response;
      response = {
        error: "Request timed out"
      };
      Object.assign(response, context);
      return reject(response);
    }, ms);
    clear_res = function(res) {
      clearTimeout(timeout_timeout);
      return resolve(res);
    };
    clear_rej = function(rej) {
      clearTimeout(timeout_timeout);
      return reject(rej);
    };
    return p.then(clear_res, clear_rej);
  });
};

fetch$ = function(method, url, options) {
  var _options, base_url, body, context, fetch_promise, query, timeout;
  if (options == null) {
    options = {};
  }
  options.method = method;
  if (query = options.query) {
    url += makeQueryString(query);
    delete options.query;
  }
  if (body = options.body) {
    options.body = JSON.stringify(body);
  }
  _options = deepExtend({}, fetch$.default_options, options);
  options = _options;
  context = {
    method: method,
    url: url,
    query: query,
    body: body
  };
  if (base_url = options.base_url) {
    if (!(url.match(/^https?:/))) {
      url = base_url + url;
    }
  }
  fetch_promise = fetch(url, options).then(function(res) {
    if (res.status === 200) {
      if (options.headers['Accept'] === 'application/json') {
        return res.json()["catch"](function(err) {
          return Promise.reject("Could not parse response");
        });
      } else {
        return res.text();
      }
    } else {
      return res.text().then(function(json_string) {
        var e, error, json;
        if (!json_string.length) {
          return "Error " + res.status + " with no response";
        }
        try {
          json = JSON.parse(json_string);
          return json;
        } catch (error) {
          e = error;
          return {
            error: json_string
          };
        }
      }).then(function(response) {
        Object.assign(response, context);
        return Promise.reject(response);
      });
    }
  });
  if (timeout = options.timeout) {
    fetch_promise = timeoutPromise(context, fetch_promise, timeout);
  }
  return Kefir.fromPromise(fetch_promise);
};

fetch$.default_options = {
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  credentials: 'same-origin'
};

fetch$.setDefaultOptions = function(options) {
  return deepExtend(fetch$.default_options, options);
};

module.exports = fetch$;
